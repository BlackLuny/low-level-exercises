    Determine whether it is in Thumb or ARM state.
    Explain each instruction's semantic. If the instruction is LDR/STR, explain the addressing mode as well.
    Identify the types (width and signedness) for every possible object. For structures, recover field size, type, and friendly name whenever possible. Not all structure fields will be recoverable because the function may only access a few fields. For each type recovered, explain to yourself (or someone else) how you inferred it.
    Recover the function prototype.
    Identify the function prologue and epilogue.
    Explain what the function does and then write pseudo-code for it.
    Decompile the function back to C and give it a meaningful name.

1. The code is in ARM mode as all the instructions are at least 32 bits long.
2. LDR source, destination | STR destination, source
3. @ line 58: the exclamation mark simply saves all the operations executed on 
              the register R0. arg0.field0x1_int32 = 0x2D

3. struct arg0 {
	int8_t field0x0_c;
	// this one is used by the function
	int8_t field0x1_c;
   }

4. int function(struct arg0, arg1)

5. Function prologue: line 02   epilogue: line 41-42

6.

type func (struct arg0, arg1)
	if (arg0 == 0x2D)

	else if (arg0 <= 0x2B)
		arg0 = arg0.field0x1

        // line 10
        if (arg0 == 0x30)
                // increase the number until it equates to 0x30
                arg0 = arg0 + arg0 + 1;
                do {
                       arg0++;
                } while (arg0 );
        
        // set some registers to 0
        // does some other stuff

        // this actually makes no sense
        if (arg0 < 0x30) {
                //    R6
                if ( (0|1) >= 0x80000000) {
                        return 0;
                }
                if ( R6 == 0) {
                        return 1;
                }
        }
                
